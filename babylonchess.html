<!DOCTYPE html>
<html>
<head>
    <title>Babylon.js Chess Game</title>
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
</head>
<body>
    <canvas id="renderCanvas" style="width: 100%; height: 100%;"></canvas>
    <script>
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);

        const createScene = () => {
            const scene = new BABYLON.Scene(engine);

            // Camera
            const camera = new BABYLON.ArcRotateCamera("camera", -Math.PI / 2, Math.PI / 2.5, 15, BABYLON.Vector3.Zero(), scene);
            camera.attachControl(canvas, true);

            // Light
            const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

            // Chessboard
            const boardSize = 8;
            const tileSize = 1;
            const tiles = [];
            const boardMaterialWhite = new BABYLON.StandardMaterial("whiteTileMat", scene);
            boardMaterialWhite.diffuseColor = new BABYLON.Color3(1, 1, 1);
            const boardMaterialBlack = new BABYLON.StandardMaterial("blackTileMat", scene);
            boardMaterialBlack.diffuseColor = new BABYLON.Color3(0, 0, 0);

            for (let row = 0; row < boardSize; row++) {
                tiles[row] = [];
                for (let col = 0; col < boardSize; col++) {
                    const tile = BABYLON.MeshBuilder.CreateBox(`tile${row}_${col}`, { size: tileSize }, scene);
                    tile.position = new BABYLON.Vector3(col - boardSize / 2 + 0.5, 0, row - boardSize / 2 + 0.5);
                    tile.material = (row + col) % 2 === 0 ? boardMaterialWhite : boardMaterialBlack;
                    tiles[row][col] = tile;
                }
            }

            // Chess pieces
            const createPiece = (type, color, row, col) => {
                let mesh;
                const baseHeight = 0.5;

                if (type === "pawn") {
                    mesh = BABYLON.MeshBuilder.CreateCylinder(`${color}_pawn`, { diameter: 0.5, height: baseHeight }, scene);
                } else if (type === "rook") {
                    mesh = BABYLON.MeshBuilder.CreateBox(`${color}_rook`, { size: 0.6 }, scene);
                } else if (type === "knight") {
                    mesh = BABYLON.MeshBuilder.CreateSphere(`${color}_knight`, { diameter: 0.6 }, scene);
                } else if (type === "bishop") {
                    mesh = BABYLON.MeshBuilder.CreateCylinder(`${color}_bishop`, { diameter: 0.4, height: baseHeight * 1.5 }, scene);
                } else if (type === "queen") {
                    mesh = BABYLON.MeshBuilder.CreateTorus(`${color}_queen`, { diameter: 0.6, thickness: 0.2 }, scene);
                } else if (type === "king") {
                    mesh = BABYLON.MeshBuilder.CreateCylinder(`${color}_king`, { diameter: 0.6, height: baseHeight * 2 }, scene);
                }

                mesh.position = tiles[row][col].position.add(new BABYLON.Vector3(0, baseHeight / 2, 0));
                mesh.material = new BABYLON.StandardMaterial(`${color}_mat`, scene);
                mesh.material.diffuseColor = color === "white" ? new BABYLON.Color3(1, 1, 1) : new BABYLON.Color3(0, 0, 0);
                mesh.row = row;
                mesh.col = col;
                mesh.color = color;
                mesh.type = type;

                return mesh;
            };

            const pieces = [];
            const setupPieces = () => {
                const pieceOrder = ["rook", "knight", "bishop", "queen", "king", "bishop", "knight", "rook"];

                for (let col = 0; col < boardSize; col++) {
                    pieces.push(createPiece("pawn", "white", 6, col));
                    pieces.push(createPiece("pawn", "black", 1, col));
                    pieces.push(createPiece(pieceOrder[col], "white", 7, col));
                    pieces.push(createPiece(pieceOrder[col], "black", 0, col));
                }
            };

            setupPieces();

            // Game state
            let currentPlayer = "white";
            let selectedPiece = null;

            const highlightTile = (tile, highlight) => {
                const highlightColor = new BABYLON.StandardMaterial("highlightMat", scene);
                highlightColor.diffuseColor = new BABYLON.Color3(0, 1, 0);

                if (highlight) {
                    tile.material = highlightColor;
                } else {
                    tile.material = (tile.position.x + tile.position.z) % 2 === 0 ? boardMaterialWhite : boardMaterialBlack;
                }
            };

            const isValidMove = (piece, targetRow, targetCol) => {
                // Basic rules for pawns
                if (piece.type === "pawn") {
                    const direction = piece.color === "white" ? -1 : 1;
                    const startRow = piece.color === "white" ? 6 : 1;

                    // Standard move
                    if (piece.row + direction === targetRow && piece.col === targetCol) {
                        return true;
                    }

                    // Double move from starting position
                    if (piece.row === startRow && piece.row + 2 * direction === targetRow && piece.col === targetCol) {
                        return true;
                    }

                    // Capture move
                    if (
                        piece.row + direction === targetRow &&
                        Math.abs(piece.col - targetCol) === 1 &&
                        pieces.some(
                            (p) => p.row === targetRow && p.col === targetCol && p.color !== piece.color
                        )
                    ) {
                        return true;
                    }
                }

                // Add rules for other pieces here...

                return false;
            };

            scene.onPointerDown = (evt, pickResult) => {
                const pickedMesh = pickResult.pickedMesh;

                if (!pickedMesh) return;

                if (pieces.includes(pickedMesh)) {
                    // Select piece
                    if (pickedMesh.color === currentPlayer) {
                        selectedPiece = pickedMesh;
                    }
                } else if (selectedPiece && pickedMesh.name.startsWith("tile")) {
                    // Attempt to move piece
                    const [_, targetRow, targetCol] = pickedMesh.name.match(/tile(\d)_(\d)/).map(Number);

                    if (isValidMove(selectedPiece, targetRow, targetCol)) {
                        selectedPiece.position = tiles[targetRow][targetCol].position.add(new BABYLON.Vector3(0, 0.5, 0));
                        selectedPiece.row = targetRow;
                        selectedPiece.col = targetCol;
                        currentPlayer = currentPlayer === "white" ? "black" : "white";
                        selectedPiece = null;
                    }
                }
            };

            return scene;
        };

        const scene = createScene();

        engine.runRenderLoop(() => {
            scene.render();
        });

        window.addEventListener("resize", () => {
            engine.resize();
        });
    </script>
</body>
</html>
